#!/usr/bin/env python3

from subprocess import Popen, PIPE
import sys
import json
import os
import argparse
from pathlib import Path
import requests
import base64
import stat
import shutil
import tempfile

# RECKLESS_CONFIG = None

github_repos = ['niftynei/sitzprobe',
                'endothermicdev/impscan']

RPI_JSON = """{
"impscan":{"repository":"https://github.com/endothermicdev/impscan","entry":"impscan"},
"currencyrate":{"repository":"https://github.com/lightningd/plugins","entry":"currencyrate.py","subdir":"currencyrate"},
"summary": {"repository": "https://api.github.com/repos/lightningd/plugins/contents/summary", "entry": "summary.py"},
"rebalance": {"repository": "https://api.github.com/repos/lightningd/plugins/contents/rebalance", "entry": "rebalance.py"},
"helpme": {"repository": "https://api.github.com/repos/lightningd/plugins/contents/helpme", "entry": "helpme.py"},
"noise": {"repository": "https://api.github.com/repos/lightningd/plugins/contents/noise", "entry": "noise.py"}
}"""

# Reckless plugin index
rpi = json.loads(RPI_JSON)  # replace with a file once this is working.

reck_conf_txt = '# This configuration file is managed by reckless to' +\
                ' activate and disable\n# reckless-installed plugins\n'


class inst_info:
    def __init__(self, name, url, git_url):
        self.name = name
        self.repo = url
        self.git_url = git_url
        self.entry = None
        self.deps = None
        self.subdir = None

    def __repr__(self):
        return f'name: {self.name}\nrepo: {self.repo}\ngit: {self.git_url}'\
               f'\nentry:{self.entry}\ndepency source:{self.deps}'

    def get_inst_details(self):
        """
        Populate installation details from a github repo.
        Return True if all data is found.
        """
        r = requests.get(self.git_url)
        if r.status_code != 200:
            return False
        tree = r.json()['tree']
        entry_guesses = [self.name, f'{self.name}.py', '__init__.py']
        for g in entry_guesses:
            for f in tree:
                # print(f['path'])
                if f['path'] == g:
                    self.entry = g
                    break
            if self.entry is not None:
                break
        dependency_info = ['requirements.txt', 'pyproject.toml']
        for d in dependency_info:
            for f in tree:
                if f['path'] == d:
                    self.deps = d
                    break
            if self.deps is not None:
                break
        if not self.entry:
            return False
        if not self.deps:
            return False
        return True


def create_dir(r, d):
    """Creation of a directory at path `d` with a maximum new dir depth `r`"""
    if os.path.exists(d):
        return True
    elif r <= 0:
        return False
    elif create_dir(r-1, os.path.split(d)[0]):
        os.mkdir(d, 0o777)
        print(f'created directory {d}')
        if os.path.exists(d):
            return True


def remove_dir(target):
    try:
        shutil.rmtree(target)
        return True
    except NotADirectoryError:
        print(f"Tried to remove directory {target} that does not exist.")
    except PermissionError:
        print(f"Permission denied removing dir: {target}")
    return False


class config(object):
    def obtain_config(self, config_path, default_text):
        """Return a config file from the desired location. Create one with
        default_text if it cannot be found."""
        # print(f'config requested with path: \"{config_path}\"')
        # FIXME: warn if reckless dir exists, but conf not found
        if os.path.exists(config_path):
            with open(config_path, 'r+') as f:
                config_content = f.readlines()
            return config_content
        parent_path = os.path.split(config_path)[0]
        # Create up to one parent in the directory tree.
        if create_dir(1, parent_path):
            with open(self.conf_fp, 'w') as f:
                f.write(default_text)
                # FIXME: Handle write failure
                return default_text
        else:
            print('could not create the parent directory')
            return None

    def editConfigFile(self, addline, removeline):
        remove_these_lines = []
        with open(self.conf_fp, 'r') as reckless_conf:
            original = reckless_conf.readlines()
            empty_lines = []
            for n, l in enumerate(original):
                if (l.strip() == removeline):
                    remove_these_lines.append(n)
                    continue
                if (l.strip() == ''):
                    empty_lines.append(n)
                    if ((n-1) in empty_lines):
                        # The white space is getting excessive.
                        remove_these_lines.append(n)
                        continue
            with open(self.conf_fp, 'w') as conf_write:
                line_exists = False
                for n, l in enumerate(original):
                    if n not in remove_these_lines:
                        conf_write.write(l)
                        if addline == l:
                            # addline is idempotent
                            line_exists = True
                if not line_exists:
                    conf_write.write('\n{}'.format(addline))

    def enable_plugin(self, plugin_path):
        """Handle persistent plugin loading via config"""
        self.editConfigFile(f'plugin={plugin_path}',
                            f'disable-plugin={plugin_path}')

    def disable_plugin(self, plugin_path):
        """Handle persistent plugin disabling via config"""
        self.editConfigFile(f'disable-plugin={plugin_path}',
                            f'plugin={plugin_path}')

    def __init__(self, file_path=None, default_text=None):
        if file_path is not None:
            # conf_fp is the sub-config file inherited by .lightning/config
            self.conf_fp = file_path
        else:
            # default file path
            self.conf_fp = Path.home().joinpath('.lightning', 'reckless',
                                                'reckless.conf')
            # self._check_lightning_config()
        self.content = self.obtain_config(self.conf_fp, default_text)


class reckless_config(config):
    """Reckless config (by default, specific to the bitcoin network only.)
    This is inherited by the main lightningd config and contains all reckless
    maintained plugins."""

    def __init__(self, file_path=None, default_text=None):
        if file_path is None:
            file_path = Path.home().joinpath('.lightning', 'reckless',
                                             'bitcoin-reckless.conf')
        if default_text is None:
            default_text = '# This configuration file is managed by reckles' +\
                           's to activate and disable\n# reckless-installed' +\
                           ' plugins\n'
        config.__init__(self, file_path=file_path, default_text=default_text)
        self.reckless_dir = os.path.split(file_path)[0]


class lightning_bitcoin_config(config):
    """lightningd config specific to the bitcoin network. This is inherited by
    the main lightningd config and in turn, inherits bitcoin-reckless.conf."""

    def __init__(self, file_path=None, default_text=None):
        if file_path is None:
            file_path = Path.home().joinpath('.lightning', 'bitcoin',
                                             'config')
        if default_text is None:
            default_text = "# This config was autopopulated by reckless\n"

        config.__init__(self, file_path=file_path, default_text=default_text)


def help(target):
    parser.print_help(sys.stdout)


def _search_index(name):
    for i in rpi.keys():
        if i == name:
            return (rpi[i])
    return False


def _search_plugins_repo(name):
    plugins_cont = "https://api.github.com/repos/lightningd/plugins/contents/"
    r = requests.get(plugins_cont, timeout=5)
    if r.status_code != 200:
        print("Plugin repository unavailable")
        return False
    for x in r.json():
        if x["name"] == name:
            plug = {}
            # Look for the rest of the install details
            if 'lightningd/plugins/' in x['html_url']:
                plug.update({'repository': 'https://github.com/'
                             'lightningd/plugins'})
                plug.update({'subdir': name})
                MyPlugin = inst_info(name,
                                     'https://github.com/lightningd/plugins',
                                     x['git_url'])
                MyPlugin.subdir = x['name']
            else:
                plug.update({'repository': x['html_url']})
                MyPlugin = inst_info(name, x['html_url'], x['git_url'])
            MyPlugin.get_inst_details()
            plug.update({'entry': None})
            return MyPlugin
    return False


def _install_plugin(source):
    """make sure the repo exists and clone it."""
    if RECKLESS_CONFIG is None:
        print('error: reckless install directory unavailable')
        sys.exit(2)
    req = requests.get(source.repo, timeout=20)
    if not req.status_code == 200:
        print('plugin source repository unavailable')
        sys.exit(1)
    # Use a unique directory for each cloned repo.
    clone_path = 'reckless-{}'.format(str(hash(os.times()))[-9:])
    clone_path = os.path.join(tempfile.gettempdir(), clone_path)
    inst_path = os.path.join(RECKLESS_CONFIG.reckless_dir,
                             source.name)
    if os.path.exists(clone_path):
        print(f'{clone_path} already exists - deleting')
        shutil.rmtree(clone_path)
    # clone repository to /tmp/<plugin>
    if 'api.github.com' in source.repo:
        repo = source.repo.replace('/contents', '/git/trees/master?recursive=1')
        repo_contents_json = requests.get(repo).json()
        content_selected_plugin = filter(lambda element: element['path'].startswith(source.name), repo_contents_json['tree'])
        for element in content_selected_plugin:
            file_name = element['path'].split('/')[-1]
            if element['mode'] == '040000':
                print('Downloading into', clone_path)
                os.makedirs(inst_path)
            else:
                abs_path = clone_path + '/' + file_name
                url_response = requests.get(element['url'],
                                            allow_redirects=True)
                decoded_file_content = base64.b64decode(url_response.json()['content']) if url_response.json()['content'] else ''
                print('Writing content into', abs_path)
                print(type(decoded_file_content))
                open(abs_path, 'wb').write(decoded_file_content)
                if element['mode'] == '100755':
                    os.chmod(abs_path, os.stat(abs_path).st_mode | stat.S_IEXEC)
    elif 'github.com' in source.repo:
        git = Popen(['git', 'clone', source.repo, clone_path], stdout=PIPE)
        git.wait()
        if git.returncode != 0:
            print('Error: Failed to clone repo')
            print(git.stdout.read())
            remove_dir(clone_path)
            return
    # Install dependencies via requirements.txt
    install_methods = {
        'requirements.txt': ['pip', 'install', '-r', 'requirements.txt'],
        'pyproject.toml': ['pip', 'install', '-e', '.']
    }

    print(f'installing requirements from {source.deps}')
    plugin_path = clone_path
    if source.subdir is not None:
        plugin_path = os.path.join(clone_path, source.subdir)
    os.chdir(plugin_path)
    if source.deps is not None:
        procedure = install_methods[source.deps]
        pip = Popen(procedure, stdout=PIPE)
        pip.wait()
        if pip.returncode == 0:
            print('requirements installed successfully.')
        else:
            print(pip.stdout.read())
    # FIXME: test/verify

    # Find this cute little plugin a forever home
    shutil.copytree(plugin_path, inst_path)
    print(f'plugin installed: {inst_path}')
    remove_dir(clone_path)


def install(plugin_name):
    """reckless install <plugin>
    downloads plugin from source repos and installs plugin"""
    if plugin_name is None:
        print('missing argument: plugin_name')
    source = _search_plugins_repo(plugin_name)
    if source:
        print('Retrieving {} from {}'.format(plugin_name,
                                             source.repo))
        _install_plugin(source)
        inst_path = os.path.join(RECKLESS_CONFIG.reckless_dir,
                                 source.name,
                                 source.entry)
        RECKLESS_CONFIG.enable_plugin(inst_path)
        # FIXME: Go ahead and dynamically activate?


def uninstall(plugin_name):
    """reckless uninstall <plugin>
    disables plugin and deletes the plugin's reckless dir"""
    if plugin_name is not None:
        # FIXME: Do something here.
        print('Uninstalling plugin {}'.format(plugin_name))
        disable(plugin_name)
        plugin_dir = os.path.join(RECKLESS_CONFIG.reckless_dir, plugin_name)
        print("looking for {}".format(plugin_dir))
        if remove_dir(plugin_dir):
            print(f"{plugin_name} uninstalled successfully.")


def search(plugin_name):
    """reckless search <plugin>
    searches plugin index for plugin"""
    if plugin_name is not None:
        p = _search_plugins_repo(plugin_name)
        if p:
            print(f"found plugin repo:\n{p.repo}")
            print(f"entry: {p.entry}")
            if p.subdir:
                print(f'sub-directory: {p.subdir}')
        else:
            print(f'{plugin_name} not found.')


def update(plugin_name):
    """reckless update <plugin>
    removes plugin and installs latest version"""
    # if len(sys.argv) > 2:
    if plugin_name is not None:
        # print('updating plugin {}'.format(sys.argv[2]))
        print('updating plugin {}'.format(plugin_name))
        # FIXME: do something.


def enable(plugin_name):
    """reckless enable <plugin>
    dynamically activates plugin and adds to config (persistent)"""
    # if len(sys.argv) > 2:
    if plugin_name is None:
        sys.stderr.write('Plugin name required.')
        sys.exit(1)
    path = os.path.join(RECKLESS_CONFIG.reckless_dir,
                        plugin_name,
                        rpi[plugin_name]['entry'])
    # FIXME: verify we can dynamically activate (lightning rpc available)
    print('activating {}'.format(plugin_name))
    # print('using dir {}'.format(path))
    if not os.path.exists(path):
        print('cannot find installed plugin at expected path {}'
              .format(path))
        sys.exit(1)
    clncli = Popen(['lightning-cli', 'plugin', 'start', path], stdout=PIPE)
    clncli.wait()
    # print('debug only!')
    # print(clncli.stdout.read())
    RECKLESS_CONFIG.enable_plugin(path)
    sys.exit(clncli.returncode)


def disable(plugin_name):
    """reckless disable <plugin>
    deactivates an installed plugin"""
    if plugin_name is None:
        sys.stderr.write('Plugin name required.')
        sys.exit(1)
    path = os.path.join(RECKLESS_CONFIG.reckless_dir,
                        plugin_name,
                        rpi[plugin_name]['entry'])
    if not os.path.exists(path):
        sys.stderr.write(f'Could not find plugin at {path}\n')
        sys.exit(1)
    clncli = Popen(['lightning-cli', 'plugin', 'stop',
                    rpi[plugin_name]['entry']],
                   stdout=PIPE, stderr=PIPE)
    clncli.wait()
    output = json.loads(clncli.stdout.read().decode()
                        .replace('\n', '').replace('   ', ''))
    # print(output)
    if ('code' in output.keys() and output['code'] == -32602):
        print('plugin not currently running')
    elif clncli.returncode != 0:
        print('lightning-cli plugin stop failed')
        sys.stderr.write(clncli.stderr.read().decode())
        sys.exit(clncli.returncode)
    RECKLESS_CONFIG.disable_plugin(path)
    print(f'{plugin_name} disabled')


# FIXME pass config in here if passed by argument.
def loadConfig():
    """Initial directory discovery and config file creation."""
    # Reckless manages plugins here.
    reckless_conf = reckless_config()
    if not reckless_conf:
        print('Error: reckless config file could not be written')
        sys.exit(1)
    # This config file inherits the reckless_config.
    bc_conf = lightning_bitcoin_config()
    if not bc_conf:
        print('Error: could not load/create .lightning/bitcoin config')
        sys.exit(1)
    bc_conf.editConfigFile(f'include {reckless_conf.conf_fp}', None)
    return reckless_conf


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(dest='command', help='install/uninstall/search/update',
                        type=str)
    parser.add_argument(dest='target', nargs='?', default=None, help='target',
                        type=str)
    parser.add_argument('-d', '--reckless-dir',
                        help='specify a data directory for reckless to use',
                        type=str, default=None)
    parser.add_argument('-c', '--conf', help='sub-config file reckless uses '
                        'to enable/disable plugins (default: '
                        'reckless/reckless.conf)', default=None)
    args = parser.parse_args()

    if hasattr(args, 'command'):
        # FIXME: Check for config file passed by option and load it here.
        if args.command in ['install', 'uninstall', 'search', 'update',
                            'enable', 'disable', 'help']:
            RECKLESS_CONFIG = loadConfig()
            globals()[args.command](args.target)
            sys.exit(0)
        elif args.command == 'firstrun':
            loadConfig()
        else:
            print(f'{args.command}: command unrecognized')
